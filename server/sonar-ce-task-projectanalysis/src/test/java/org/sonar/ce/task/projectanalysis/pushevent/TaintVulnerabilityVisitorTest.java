/*
 * SonarQube
 * Copyright (C) 2009-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.ce.task.projectanalysis.pushevent;

import java.util.Date;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.ArgumentMatcher;
import org.sonar.api.rule.RuleKey;
import org.sonar.api.rules.RuleType;
import org.sonar.ce.task.projectanalysis.analysis.AnalysisMetadataHolderRule;
import org.sonar.ce.task.projectanalysis.analysis.TestBranch;
import org.sonar.ce.task.projectanalysis.component.Component;
import org.sonar.ce.task.projectanalysis.component.Component.Status;
import org.sonar.ce.task.projectanalysis.component.Component.Type;
import org.sonar.ce.task.projectanalysis.component.ComponentImpl;
import org.sonar.ce.task.projectanalysis.component.MutableTreeRootHolderRule;
import org.sonar.ce.task.projectanalysis.component.ReportAttributes;
import org.sonar.ce.task.projectanalysis.component.ReportComponent;
import org.sonar.core.issue.DefaultIssue;
import org.sonar.db.protobuf.DbCommons;
import org.sonar.db.protobuf.DbIssues;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

public class TaintVulnerabilityVisitorTest {

  private final PushEventRepository repositoryMock = mock(PushEventRepository.class);
  @Rule
  public MutableTreeRootHolderRule treeRootHolder = new MutableTreeRootHolderRule();
  @Rule
  public AnalysisMetadataHolderRule analysisMetadataHolder = new AnalysisMetadataHolderRule()
    .setBranch(new TestBranch("develop"));

  private final TaintVulnerabilityVisitor underTest = new TaintVulnerabilityVisitor(repositoryMock, analysisMetadataHolder, treeRootHolder);

  @Test
  public void add_event_to_repository_if_taint_vulnerability_is_new() {
    buildComponentTree();
    Component component = createIssueComponent();
    DefaultIssue defaultIssue = createDefaultIssue()
      .setNew(true);

    underTest.onIssue(component, defaultIssue);

    verify(repositoryMock).add(argThat(PushEventMatcher.eq(new PushEvent<>().setName("TaintVulnerabilityRaised"))));
  }

  @Test
  public void add_event_to_repository_if_taint_vulnerability_is_copied() {
    buildComponentTree();
    Component component = createIssueComponent();
    DefaultIssue defaultIssue = createDefaultIssue()
      .setCopied(true);

    underTest.onIssue(component, defaultIssue);

    verify(repositoryMock).add(argThat(PushEventMatcher.eq(new PushEvent<>().setName("TaintVulnerabilityRaised"))));
  }

  @Test
  public void skip_issue_if_issue_changed() {
    Component component = createIssueComponent();

    DefaultIssue defaultIssue = new DefaultIssue()
      .setChanged(true)
      .setType(RuleType.VULNERABILITY)
      .setRuleKey(RuleKey.of("javasecurity", "S123"));

    underTest.onIssue(component, defaultIssue);

    verify(repositoryMock, times(0)).add(any(PushEvent.class));
  }

  @Test
  public void skip_if_issue_not_from_taint_vulnerability_repository() {
    Component component = createIssueComponent();

    DefaultIssue defaultIssue = new DefaultIssue()
      .setChanged(true)
      .setType(RuleType.VULNERABILITY)
      .setRuleKey(RuleKey.of("weirdrepo", "S123"));

    underTest.onIssue(component, defaultIssue);

    verify(repositoryMock, times(0)).add(any(PushEvent.class));
  }

  @Test
  public void skip_if_issue_is_a_hotspot() {
    Component component = createIssueComponent();

    DefaultIssue defaultIssue = new DefaultIssue()
      .setChanged(true)
      .setType(RuleType.SECURITY_HOTSPOT)
      .setRuleKey(RuleKey.of("javasecurity", "S123"));

    underTest.onIssue(component, defaultIssue);

    verify(repositoryMock, times(0)).add(any(PushEvent.class));
  }

  @Test
  public void skip_if_issue_does_not_have_locations() {
    Component component = createIssueComponent();

    DefaultIssue defaultIssue = new DefaultIssue()
      .setChanged(true)
      .setType(RuleType.VULNERABILITY)
      .setRuleKey(RuleKey.of("javasecurity", "S123"));

    underTest.onIssue(component, defaultIssue);

    verify(repositoryMock, times(0)).add(any(PushEvent.class));
  }

  private void buildComponentTree() {
    treeRootHolder.setRoot(ReportComponent.builder(Type.PROJECT, 1)
      .setUuid("uuid_1")
      .addChildren(ReportComponent.builder(Type.FILE, 2)
        .setUuid("issue-component-uuid")
        .build())
      .addChildren(ReportComponent.builder(Type.FILE, 3)
        .setUuid("location-component-uuid")
        .build())
      .build());
  }

  private ComponentImpl createIssueComponent() {
    return ComponentImpl.builder(Type.FILE)
      .setReportAttributes(mock(ReportAttributes.class))
      .setUuid("issue-component-uuid")
      .setDbKey("issue-component-key")
      .setName("project/SomeClass.java")
      .setStatus(Status.ADDED)
      .build();
  }

  private DefaultIssue createDefaultIssue() {
    return new DefaultIssue()
      .setType(RuleType.VULNERABILITY)
      .setCreationDate(new Date())
      .setLocations(DbIssues.Locations.newBuilder()
        .addFlow(DbIssues.Flow.newBuilder()
          .addLocation(DbIssues.Location.newBuilder()
            .setChecksum("checksum")
            .setComponentId("location-component-uuid")
            .build())
          .build())
        .setTextRange(DbCommons.TextRange.newBuilder()
          .setStartLine(1)
          .build())
        .build())
      .setRuleKey(RuleKey.of("javasecurity", "S123"));
  }

  private static class PushEventMatcher implements ArgumentMatcher<PushEvent<?>> {

    private final PushEvent<?> left;

    static PushEventMatcher eq(PushEvent<?> left) {
      return new PushEventMatcher(left);
    }

    private PushEventMatcher(PushEvent<?> left) {
      this.left = left;
    }

    @Override
    public boolean matches(PushEvent<?> right) {
      return left.getName().equals(right.getName());
    }
  }

}
